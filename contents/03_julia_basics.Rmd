# Learning the basics of Julia {#sec:julia}

This chapter was written by Vivek Srikrishnan and Patrick J. Applegate.

### Learning objectives {-}

After completing this chapter, you should be able to
* install [Julia](https://julialang.org)
* write basic Julia commands with appropriate syntax
    + assigning values to variables
    + the differences between scalars and arrays
    + using indexing to extract individual values, or ranges of values, from variables
    + use loops and `if-else` statements to control the flow of your script's execution
    + write functions for more readable code which is easier to debug
* modify a Julia script to produce a desired result
* get help by
    + searching the Web
    + asking questions in a way that increases your chance of receiving a helpful response

## Introduction

The computing environment and programming language [Julia](http://julialang.org) is a powerful tool for risk analysis.  This chapter will guide you through installing Julia and using a text editor or development environment (such as [Visual Studio Code](https://code.visualstudio.com/) or [Atom](https://atom.io/)) to write and edit Julia scripts.  You will also learn the basics of using Julia, including how to manage, install, and load packages. Finally, you'll become familiar with different ways of getting help when you encounter problems with your Julia code.

## Getting Started

### Why Julia?

Julia is a powerful emerging programming language. Julia code is relatively readable while still executing quickly. While initially the Julia community was relatively limited, this has changed in recent years, and there is a wide ecosystem of packages which provide additional functionality to the base Julia release.

### Installing Julia

**To install Julia**, navigate to <https://julialang.org/> and look for the link that says, "Download" near the top of the page.  Click on this link and follow the instructions for installing the current stable release version which is appropriate for your computing environment. This textbook is currently built using Julia v.1.6.4.

By default, Julia provides a command-line interface for running commands and executing scripts, as well as the interactive ["REPL"](https://docs.julialang.org/en/v1/stdlib/REPL/) (read-eval-print-loop). The REPL is started by calling `julia` with no arguments or by double-clicking the Julia executable icon, while calling `julia <scriptname.jl>` will execute `scriptname.jl`. We recommend that you install and use a text editor or integrated development environment (IDE) for opening and editing Julia scripts, which can then be executed at the command line. One popular IDE is [Visual Studio Code](https://code.visualstudio.com/), which has a powerful [Julia extension](https://code.visualstudio.com/docs/languages/julia) which includes autocompletion, syntax monitoring, an integrated REPL, a plot pane, and other features. [Atom](https://atom.io/) is another popular text editor which can be extended using [Juno](https://junolab.org/) for advanced Julia features (though Juno is currently depreciated in favor of the VS Code Julia extension). However, if you currently use a particular IDE or editor for coding, it will work well for Julia programming!

### Why write scripts?

It's possible to do quite a bit in Julia just by issuing commands one-at-a-time in the REPL.  However, real scientific analyses should be *reproducible*; that is, there should be a list of steps that anyone can follow to get the same results as the person who originally did the analysis.  Saving these steps as a script allows others to execute your code easily and helps ensure consistent results. 

### Package and environment management

Another important component of reproducibility is ensuring that others are using the same packages and package *versions* as you did, as updates could result in different output or different commands. Julia has a powerful package management system, [`Pkg`](https://docs.julialang.org/en/v1/stdlib/Pkg/). In the REPL, this interface can be accessed by entering `]` at the `julia>` prompt. In a script, we will directly interact with the `Pkg` package, as we will see over the course of this book.

### Getting help

What should you do if you don't understand what a Julia command does or how to achieve a particular coding goal? If you have a specific command that you'd like more information on, you can type `?functionname` at a code prompt or in the REPL to get help. Your first external resource should be the [Julia documentation](https://docs.julialang.org/en/v1/) or the documentation for the particular package you're drawing from. If you can't find the solution in the documentation (or don't know where to start), a web search can often be useful, as there is an active Julia community which answers questions at the [Julia discourse](https://discourse.julialang.org/) and [Stack Overflow](https://stackoverflow.com/).

### When the documentation and searching the Internet don't help

When you encounter problems in writing R code that you can't solve by looking at the documentation or searching the Internet, you'll want to ask someone who knows more about Julia than you do.  When you do, you should try to ask your questions in a way that maximizes your chances of getting the help you need.

:::: {.center data-latex=""}

::: {.info data-latex=""}
Before asking any questions, you should use the resources available to you, as mentioned above: search the documentation and the Web.  In particular, if you get an error message, try pasting it into Google.
:::

::::

If you still require assistance, your question should say clearly

1. what you are trying to do (the goal of your program)
2. what your program does that addresses the problem
3. what you were expecting to have happen when you ran your program
4. what actually happened (did you get an error message?  if so, what did it say?)
5. what you did to try and solve your problem before asking your question

For an example of a well-written question, have a look at [this post](http://stackoverflow.com/questions/15962111/error-using-apply-function-in-r-on-tutorial-example) on [Stack Overflow](http://www.stackoverflow.com).  Note that the original poster (user tjnel) addressed all of the five points above in his/her question; he/she

* says explicitly that he/she is trying to reproduce the results from a tutorial (question #1, above),
* gives the code that is being used, allowing others to fully understand the problem (#2)
* provides the expected output from running the code in the tutorial (#3),
* shows the error message that he/she obtained when running the tutorial code (#4),
* shows that he/she tried to reproduce a different part of the tutorial exercise before asking a question (#5).

For other ideas about asking good questions, have a look at [Stack Overflow](http://www.stackoverflow.com)'s article on "[How do I ask a good question?](http://stackoverflow.com/help/how-to-ask)", Jon Skeet's blog post on "[Writing the Perfect Question](https://codeblog.jonskeet.uk/2010/08/29/writing-the-perfect-question/)", and Eric S. Raymond's classic "[How to Ask Questions the Smart Way](http://www.catb.org/esr/faqs/smart-questions.html)".

## Julia Syntax

Now we will introduce some basic Julia syntax. There are several good introductions to Julia; we recommend the introductory material for the open-source MIT course [Introduction to Computational Thinking](https://computationalthinking.mit.edu/Spring21/).

### Comments

Comments hide statements from the interpreter or compiler. It's a good idea to liberally comment your code so readers (including yourself!) know why your code is structured and written the way it is.

Single-line comments in Julia are preceded with a `#`. Multi-line comments are preceded with `#=` and ended with `=#`

```{julia}
# This is a single-line comment. Everything after the "#" is not evaluated.

#=
This is a multi-line comment.

We might want to really organize our thoughts on what a function is doing in this space. We can take as much room as we want, with as many paragraphs.
=#

3+5 # now that we've exited the multi-line comment, subsequent expressions are evaluated
```

### Variables

Variables are names which correspond to some type of object. These names are bound to objects (and hence their values) using the `=` operator.

```{julia}
x=5
```

Variables can be manipulated with standard arithmetic operators.

```{julia}
x+4
```

### Data Types

Each datum (importantly, *not* the variable which is bound to it) has a [data type](https://docs.julialang.org/en/v1/manual/types/). 


:::: {.center data-latex=""}

::: {.info data-latex=""}
Strictly speaking, a variable points to a particular memory address, which holds the information associated with some datum or data. These pieces of memory can be used to store different data as the variable is overwritten. This can be restricted to varying degrees depending on the programming language. In a *statically typed* language like C, the compiler needs to allocate memory based on the data type, and so once a variable is initialized with a given type, this type cannot be changed, even if the data itself can be. In a *dynamically typed* language such as Python, the types associated with variables can be changed, which may mean the variable needs to be assigned to a different piece of memory. This is one reason why compiled (and usually statically-typed) languages are often faster than interpreted (and usually dynamically-typed) languages.
:::

::::

Julia is a dynamically-typed language, which means that you do not need to specify the type of a variable when you define it, and you can change types mid-program. While Julia is dynamically-typed, you can specify the type of a variable when it is declared by using double-colons (`::`) in the form `variable::type`. This can increase speed, but perhaps just as importantly, can make it easier to identify type errors when debugging. In general, there will be no need for the tasks in this book to worry about any data types other than `Int64` (integers), `Float64` (real numbers), `Bool` (Booleans), and `String` (strings). Julia types are similar to C types, in that they require not only the *type* of data (Int, Float, String, etc), but also the precision (which is related to the amount of memory allocated to the variable). Issues with precision won't be a big deal in this book, though they matter when you're concerned about performance vs. decimal accuracy of code.

You can identify the type of a variable or expression with the `typeof()` function.

```{julia}
typeof("This is a string")
```

```{julia}
typeof(x)
```

To specify that a numeric value should be a `Float64` instead of an `Int64` (which might be needed for some functions which expect `Float64` inputs), add a decimal (*e.g.* `9.` instead of `9`).

## Data Structures

Julia has several native data structures (that is, data structures that don't require additional packages to implement). 
